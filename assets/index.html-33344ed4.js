import{_ as a,r as t,o,c as p,a as n,b as e,e as c,d as l}from"./app-87212aaa.js";const u={},r=l(`<h1 id="分治" tabindex="-1"><a class="header-anchor" href="#分治" aria-hidden="true">#</a> 分治</h1><h2 id="分治算法" tabindex="-1"><a class="header-anchor" href="#分治算法" aria-hidden="true">#</a> 分治算法</h2><p><strong>分治(Divide And Conquer)</strong>：全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括以下两个步骤：</p><ul><li><strong>分(划分阶段)</strong>：递归的将原问题分解为两个或者多个子问题，直至到达最小问题时终止。</li><li><strong>治(合并阶段)</strong>：从已知解的最小问题开始，从底至顶地将问题的解进行合并，从而构建出原问题的解。</li></ul><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/divide_and_conquer.assets/divide_and_conquer_merge_sort.png" alt="分治算法"></p><h3 id="如何判断分治问题" tabindex="-1"><a class="header-anchor" href="#如何判断分治问题" aria-hidden="true">#</a> 如何判断分治问题</h3><ul><li><strong>问题可以分解</strong>：原问题可以分解称规模更小、类似的子问题，以及能够以相同的方式进行递归。</li><li><strong>子问题是独立的</strong>：子问题之间没有重叠，互补依赖，可以独立解决。</li><li><strong>子问题的解可以合并</strong>：原问题的解通过合并子问题的解得来。</li></ul><h3 id="分治常见应用" tabindex="-1"><a class="header-anchor" href="#分治常见应用" aria-hidden="true">#</a> 分治常见应用</h3><ul><li>常见算法：<strong>寻找最近点对</strong>、<strong>大整数乘法(例如Karatsuba)</strong>、<strong>矩阵乘法(例如Strassen)</strong>、<strong>汉诺塔问题</strong>、<strong>求解逆序对</strong>。</li><li>常见算法和数据结构：<strong>二分查找</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>桶排序</strong>、<strong>树</strong>、<strong>堆</strong>、<strong>哈希表</strong>。</li></ul><h2 id="分治搜索策略" tabindex="-1"><a class="header-anchor" href="#分治搜索策略" aria-hidden="true">#</a> 分治搜索策略</h2><p>基于分治思想，实现二分查找：将搜索区间标记为<code>[i, j]</code>，对应的子问题标记为<code>f(i, j)</code>，以原问题<code>f(0, n - 1)</code>为起始点，通过以下步骤实现二分查找：</p><ol><li>计算搜索区间<code>[i, j]</code>的中点<code>m</code>，根据它排除一半的搜索区间。</li><li>递归求解规模减小一半的子问题，可能为<code>f(i, m - 1)</code>或<code>f(m + 1, j)</code>。</li><li>循环以上两步，直至找到<code>target</code>目标元素或者搜索区间为空。</li></ol><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/binary_search_recur.assets/binary_search_recur.png" alt="基于分治实现的二分查找"></p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 区间为空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> mid <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> i<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">binarySearchRecursion</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="构建树问题" tabindex="-1"><a class="header-anchor" href="#构建树问题" aria-hidden="true">#</a> 构建树问题</h2><p>假设给定一棵二叉树的前序遍历(<code>preOrder</code>)和中序遍历(<code>inOrder</code>)，请从中构建二叉树，返回二叉树的根节点(假设二叉树中没有重复节点)。 <img src="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem.assets/build_tree_example.png" alt="构建树问题"></p><h3 id="判断是否为分治问题" tabindex="-1"><a class="header-anchor" href="#判断是否为分治问题" aria-hidden="true">#</a> 判断是否为分治问题</h3><ul><li><strong>问题可以分解</strong>：从分治角度切入，我们可以将原问题划分为两个子问题和一个初始化操作：初始化根节点、构建左子树和构建右子树。对于每棵子树，任可以复用此步骤，直至到达空子树为止。</li><li><strong>子问题是独立的</strong>：左子树和右子树相互独立，它们之间没有交集。</li><li><strong>子问题的解是可以合并的</strong>：一旦得到了左子树和右子树，我们就可以将它们链接到根节点上，得到原问题的解。</li></ul><h3 id="基于变量描述子树区间" tabindex="-1"><a class="header-anchor" href="#基于变量描述子树区间" aria-hidden="true">#</a> 基于变量描述子树区间</h3><ul><li>将当前树的根节点在<code>preOrder</code>中的索引记为<code>i</code>。</li><li>将当前树的根节点在<code>inOrder</code>中的索引记为<code>m</code>。</li><li>当前树在<code>inOrder</code>中索引区间记为<code>[l, r]</code>。</li></ul><p>根据以上变量即可表示根节点在<code>preOrder</code>中的索引以及子树在<code>inOrder</code>中的索引区间。</p><table><thead><tr><th>树</th><th>根节点在<code>preOrder</code>中的索引</th><th>子树在<code>inOrder</code>中的索引区间</th></tr></thead><tbody><tr><td>当前树</td><td>i</td><td>[l, r]</td></tr><tr><td>左子树</td><td>i + 1</td><td>[l, m - 1]</td></tr><tr><td>右子树</td><td>i + 1 + (m - l)</td><td>[m + 1, r]</td></tr></tbody></table><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem.assets/build_tree_division_pointers.png" alt="树索引和索引区间"></p><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h3><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// n为二叉树节点的数量</span>
<span class="token comment">// 时间复杂度：O(n)</span>
<span class="token comment">// 空间复杂度：O(n)</span>
<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">preOrder<span class="token punctuation">,</span> inOrderMap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 区间为空是，表示空子树，终止</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化根节点</span>
  <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 查询m，从而划分左、右子树</span>
  <span class="token keyword">const</span> m <span class="token operator">=</span> inOrderMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 构建左子树</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> inOrderMap<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 构建右子树</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> inOrderMap<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回根节点</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token parameter">preOrder<span class="token punctuation">,</span> inOrder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inOrderLen <span class="token operator">=</span> inOrder<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">const</span> inOrderMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inOrderLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inOrderMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>inOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> inOrderMap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>  inOrderLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="汉诺塔问题" tabindex="-1"><a class="header-anchor" href="#汉诺塔问题" aria-hidden="true">#</a> 汉诺塔问题</h2><p>给定三根柱子，记为<code>A</code>、<code>B</code>和<code>C</code>。起始状态下<code>A</code>上套着<code>N</code>个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这<code>N</code>个圆盘移动到柱子<code>C</code>上，并保持它们原有顺序不变，在移动圆盘的过程中，需要遵守以下规则。</p><ol><li>圆盘只能从一根柱子顶部拿出，从另一根柱子的顶部放入。</li><li>每次只能移动一个圆盘。</li><li>小圆盘必须时刻位于大圆盘之上。</li></ol><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/hanota_problem.assets/hanota_example.png" alt="汉诺塔"></p><p>我们将规模为<code>i</code>的汉诺塔问题记作<code>f(i)</code>，例如：<code>f(3)</code>代表将3个圆盘从<code>A</code>移动到<code>C</code>。</p><h3 id="基本情况" tabindex="-1"><a class="header-anchor" href="#基本情况" aria-hidden="true">#</a> 基本情况</h3><p>对于<code>f(1)</code>而言，只有一个圆盘，我们直接从<code>A</code>移动到<code>C</code>即可。</p><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/hanota_problem.assets/hanota_f1_step2.png" alt="汉诺塔f(1)"></p><p>对于<code>f(2)</code>而言，需要遵守规则，借助<code>B</code>来完成移动：</p><ol><li>先将上面的小圆盘从<code>A</code>移至<code>B</code>。</li><li>再将大圆盘从<code>A</code>移至<code>C</code>。</li><li>最后将小圆盘从<code>B</code>移至<code>C</code>。</li></ol><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/hanota_problem.assets/hanota_f2_step3.png" alt="汉诺塔f(2)"></p><h3 id="子问题分解" tabindex="-1"><a class="header-anchor" href="#子问题分解" aria-hidden="true">#</a> 子问题分解</h3><p>对于<code>f(3)</code>而言，因为已知<code>f(1)</code>和<code>f(2)</code>的解，所以我们可从分治角度思考：将<code>A</code>顶部的两个圆盘看做一个整体。</p><ol><li>令<code>B</code>为目标柱，<code>C</code>为缓冲柱，将两个圆盘从<code>A</code>移动到<code>B</code>。</li><li>将<code>A</code>中剩余的一个圆盘从<code>A</code>直接移动到<code>C</code>。</li><li>令<code>C</code>为目标柱，<code>A</code>为缓冲柱，将两个圆盘从<code>B</code>移动到<code>C</code>。</li></ol><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/hanota_problem.assets/hanota_f3_step3.png" alt="汉诺塔f(3)"></p><p>至此，我们总结出规律：将原问题<code>f(n)</code>划分为两个子问题<code>f(n - 1)</code>和<code>f(1)</code>，并按以下顺序解决这三个子问题。</p><ol><li>将<code>n - 1</code>个圆盘借助<code>C</code>从<code>A</code>移动至<code>B</code>。</li><li>将剩余1个圆盘从<code>A</code>直接移动至<code>C</code>。</li><li>将<code>n - 1</code>个圆盘借助<code>A</code>从<code>B</code>移动至<code>C</code>。</li></ol><p><img src="https://www.hello-algo.com/chapter_divide_and_conquer/hanota_problem.assets/hanota_divide_and_conquer.png" alt="汉诺塔f(n)"></p><h3 id="代码实现-1" tabindex="-1"><a class="header-anchor" href="#代码实现-1" aria-hidden="true">#</a> 代码实现</h3><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">source<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 从source柱顶部拿出一个圆盘</span>
  <span class="token keyword">const</span> pan <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将圆盘放入target柱</span>
  target<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pan<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">i<span class="token punctuation">,</span> source<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">move</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 子问题，从source上移动n - 1个圆盘到换buffer缓冲柱(借助target)</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">move</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 子问题，从buffer上移动n - 1个圆盘到target目标柱(借助source)</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> source<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">solveHanota</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,46),i={href:"https://www.hello-algo.com/chapter_divide_and_conquer/",target:"_blank",rel:"noopener noreferrer"};function d(k,h){const s=t("ExternalLinkIcon");return o(),p("div",null,[r,n("ul",null,[n("li",null,[n("a",i,[e("Hello 算法 分治"),c(s)])])])])}const g=a(u,[["render",d],["__file","index.html.vue"]]);export{g as default};
